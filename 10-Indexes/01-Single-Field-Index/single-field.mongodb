// Insert persons.json, name it contacts collection
// mongoimport persons.json -d persons -c contacts --jsonArray --drop
// run in shell

db.contacts.findOne();

db.contacts.find({"dob.age": {$gt: 60}}).count();

// How can we determine if we need an index?
// Explain plan
db.contacts.explain().find({"dob.age": {$gt: 60}});

// This shows you it looked at 5000 documents to find
// 1222 documents
db.contacts.explain("executionStats").find({"dob.age": {$gt: 60}});


// Create Index
// 1 = ascending, -1 descending
db.contacts.createIndex({"dob.age": 1}) // Can create on embedded fields

// Now you can see it only examined 1222 keys to return 1222 documents
db.contacts.explain("executionStats").find({"dob.age": {$gt: 60}});



// Understanding Index Restrictions
// If your queries often return most/all of your collection, indexes
// may not help and may hurt

// So this query returns everyone...
// Execution time is higher than $gt: 60
db.contacts.explain("executionStats").find({"dob.age": {$gt: 20}});


// Removing the index
db.contacts.dropIndex({"dob.age": 1});

// This is faster than when we had the index
// Because we have to go through all the docs anyways, w/ an index
// we have to go through the index too
db.contacts.explain("executionStats").find({"dob.age": {$gt: 20}});



// Creating Compound Indexes
db.contacts.findOne();


// Order matters
// One index, where it's a connected value
db.contacts.createIndex({"dob.age": 1, gender: 1});

db.contacts.explain().find({"dob.age": 35, gender: "male"});

// Can use the index on age lookup
db.contacts.explain().find({"dob.age": 35});

// This doesn't use index. Can only use compund index from left to right
db.contacts.explain().find({gender: "male"});



// Using Indexes for Sorting
// If you want to sort in the same way index is sorted
db.contacts.explain().find({"dob.age": 35}).sort({gender: 1});

// You can timeout if you sort on a large amount of documents
// Mongo db has memory limit (32mb), and it puts all docs in memory to sort



// Default Index
db.contacts.getIndexes();
// _id is the default index




// Configuring Indexes

// This fails due to email not being unique in collection
// So this is either a good check to see if a field is unique, or
// to make sure it stays unique
db.contacts.createIndex({email: 1}, {unique: true});




// Understanding Partial Filters

// An index can be unnecessarily big if your queries only return a small
// amount of data (most values are not being hit)
db.contacts.getIndexes();

db.contacts.dropIndex({"dob.age": 1});
db.contacts.dropIndex({"dob.age": 1, gender: 1});

db.contacts.createIndex(
    {"dob.age": 1}, 
    {partialFilterExpression: {gender: "male"}});

// You'll see a collscan instead of the index being used
// since gender wasn't part of the filter
db.contacts.explain().find({"dob.age": {$gt: 60}});

db.contacts.explain().find({"dob.age": {$gt: 60}, gender: "male"});

// Difference b/t partial and complex index, partial is smaller
// Only males in the index



// Applying the Partial Index
// Make sure these are the only docs in
db.users.insertMany([
    {name: "Max", email: "max@test.com"},
    {name: "Manu"}
]);

db.users.createIndex({email: 1}, {unique: true});

// We get an error b/c the null value for email already exists
// For mongoDB null is a value
db.users.insertOne({name: "Anna"});

// To fix this
db.users.dropIndex({email: 1});

db.users.createIndex({email: 1}, {unique: true, partialFilterExpression: {email: {$exists: true}}});
db.users.insertOne({name: "Anna"});

// This would fail however
db.users.insertOne({name: "Anna", email: "max@test.com"});




// Understanding Time-To-Live Index

// Self destroying data (session data)
db.sessions.insertOne({data: "dkslaere", createdAt: new Date()});

// This index won't delete any values present before it was created
db.sessions.createIndex({createdAt: 1}, {expireAfterSeconds: 10});

// Adding a new element triggers mongoDB to 're-do' index on table...
db.sessions.insertOne({data: "dkffyujjslaere", createdAt: new Date()});

// So both items are now gone after 10 seconds
db.sessions.find();



// Covered Query
// When totalDocsExamined = 0
db.customers.insertMany([
    {name: "Max", age: 29, salary: 3000},
    {name: "Manu", age: 30, salary: 4000}
]);

db.customers.createIndex({name: 1});

// So this is a typical plan for a typical plan
db.customers.explain("executionStats").find({name: "Max"});

// Only return indexed fields through projection
// So query is fully covered by index...very fast!
db.customers.explain("executionStats").find({name: "Max"}, {_id: 0, name: 1});




// How MongoDB Rejects a Plan
db.customers.getIndexes();

db.customers.createIndex({age: 1, name: 1});

// Order on filter doesn't matter for index
// You can see the rejected plan was to use just the name
db.customers.explain().find({name: "Max", age: 30});

// This will show all the detailed statistics for all plans
db.customers.explain("allPlansExecution").find({name: "Max", age: 30});



// Using Multi-Key Indexes
db.contacts.drop()

db.contacts.insertOne(
    {name: "Max", hobbies: ["Cooking", "Sports"], 
     addresses: [{street: "Main Street"}, {street: "Second Street"}]});

// Index an array
db.contacts.createIndex({hobbies: 1});

// Notice 'isMultiKey: true'
// Multi-keys are generally bigger (stores every value in array)
db.contacts.explain("executionStats").find({hobbies: "Sports"});

db.contacts.createIndex({addresses: 1});

// Uses a collection scan instead of index
// Why? Due to us looking for a field inside of the sub document
db.contacts.explain("executionStats").find({"addresses.street": "Main Street"});

// Uses the index now, since we are using the full document
db.contacts.explain("executionStats").find({addresses: {street: "Main Street"}});

// Something you can do...
db.contacts.createIndex({"addresses.street": 1});

// We repeat this query
// And we see it hits the index w/ a multi key
db.contacts.explain("executionStats").find({"addresses.street": "Main Street"});


// This works
// Combo of multi index and compound index
db.contacts.createIndex({name: 1, hobbies: 1});

// This doesn't
// Can create a multi keys from multiple arrays
// Would need to create a cartesian product, so it would get too big
db.contacts.createIndex({addresses: 1, hobbies: 1});




// Understanding "text" Indexes
// Special kind of multi index
// Turns the text into an array of single words
// For example:
// This product is a must-buy for all fans of modern fiction
// product must buy fans modern fiction
db.products.drop();

db.products.insertMany([
    {title: "A Book", description: "This is an awesome book about a young artisg"},
    {title: "Red T-Shirt", description: "This T-Shirt is red and it's pretty awesome"}])

// Don't do description: 1, creates a solid string index, you want an array
db.products.createIndex({description: "text"});

// Case doesn't matter, all stored lowercase for search
// Finds both
db.products.find({$text: {$search: "awesome"}});

// Finds one
db.products.find({$text: {$search: "book"}});

// Finds both (looks for red, and for book)
db.products.find({$text: {$search: "red book"}});

// Search for 'red book'
db.products.find({$text: {$search: "\"red book\""}});



// So we want to find the best search that hits both of these
// We can find the 'score' through projection
db.products.find({$text: {$search: "awesome t-shirt"}});

// You can sort by which doc matches better
db.products.find({$text: {$search: "awesome t-shirt"}}, {score: {$meta: "textScore"}}).sort({score: {$meta: "textScore"}});




// Create combined text indixes

// This causes an error since we can't have more than one text index
db.products.createIndex({title: "text"});

// However, we can combine multiple text fields into one text index
db.products.dropIndex("description_text");

db.products.createIndex({title: "text", description: "text"});

db.products.insertOne({title: "A Ship", description: "Floats perfectly"})

db.products.find({$text: {$search: "ship"}});



// Using text indexes to exclude words
db.products.find({$text: {$search: "awesome"}});

// Lets say I want to find results w/ awesome but w/o t-shirt
db.products.find({$text: {$search: "awesome -t-shirt"}});



// Setting Default Language & Using Weights

