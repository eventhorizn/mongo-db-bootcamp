// Insert persons.json, name it contacts collection
// mongoimport persons.json -d persons -c contacts --jsonArray --drop
// run in shell

db.contacts.findOne();

db.contacts.find({"dob.age": {$gt: 60}}).count();

// How can we determine if we need an index?
// Explain plan
db.contacts.explain().find({"dob.age": {$gt: 60}});

// This shows you it looked at 5000 documents to find
// 1222 documents
db.contacts.explain("executionStats").find({"dob.age": {$gt: 60}});


// Create Index
// 1 = ascending, -1 descending
db.contacts.createIndex({"dob.age": 1}) // Can create on embedded fields

// Now you can see it only examined 1222 keys to return 1222 documents
db.contacts.explain("executionStats").find({"dob.age": {$gt: 60}});



// Understanding Index Restrictions
// If your queries often return most/all of your collection, indexes
// may not help and may hurt

// So this query returns everyone...
// Execution time is higher than $gt: 60
db.contacts.explain("executionStats").find({"dob.age": {$gt: 20}});


// Removing the index
db.contacts.dropIndex({"dob.age": 1});

// This is faster than when we had the index
// Because we have to go through all the docs anyways, w/ an index
// we have to go through the index too
db.contacts.explain("executionStats").find({"dob.age": {$gt: 20}});



// Creating Compound Indexes
db.contacts.findOne();


// Order matters
// One index, where it's a connected value
db.contacts.createIndex({"dob.age": 1, gender: 1});

db.contacts.explain().find({"dob.age": 35, gender: "male"});

// Can use the index on age lookup
db.contacts.explain().find({"dob.age": 35});

// This doesn't use index. Can only use compund index from left to right
db.contacts.explain().find({gender: "male"});



// Using Indexes for Sorting
// If you want to sort in the same way index is sorted
db.contacts.explain().find({"dob.age": 35}).sort({gender: 1});

// You can timeout if you sort on a large amount of documents
// Mongo db has memory limit (32mb), and it puts all docs in memory to sort



// Default Index
db.contacts.getIndexes();
// _id is the default index




// Configuring Indexes

// This fails due to email not being unique in collection
// So this is either a good check to see if a field is unique, or
// to make sure it stays unique
db.contacts.createIndex({email: 1}, {unique: true});




// Understanding Partial Filters

// An index can be unnecessarily big if your queries only return a small
// amount of data (most values are not being hit)
db.contacts.getIndexes();

db.contacts.dropIndex({"dob.age": 1});
db.contacts.dropIndex({"dob.age": 1, gender: 1});

db.contacts.createIndex(
    {"dob.age": 1}, 
    {partialFilterExpression: {gender: "male"}});

// You'll see a collscan instead of the index being used
// since gender wasn't part of the filter
db.contacts.explain().find({"dob.age": {$gt: 60}});

db.contacts.explain().find({"dob.age": {$gt: 60}, gender: "male"});

// Difference b/t partial and complex index, partial is smaller
// Only males in the index



// Applying the Partial Index
// Make sure these are the only docs in
db.users.insertMany([
    {name: "Max", email: "max@test.com"},
    {name: "Manu"}
]);

db.users.createIndex({email: 1}, {unique: true});

// We get an error b/c the null value for email already exists
// For mongoDB null is a value
db.users.insertOne({name: "Anna"});

// To fix this
db.users.dropIndex({email: 1});

db.users.createIndex({email: 1}, {unique: true, partialFilterExpression: {email: {$exists: true}}});
db.users.insertOne({name: "Anna"});

// This would fail however
db.users.insertOne({name: "Anna", email: "max@test.com"});




// Understanding Time-To-Live Index

// Self destroying data (session data)
db.sessions.insertOne({data: "dkslaere", createdAt: new Date()});

// This index won't delete any values present before it was created
db.sessions.createIndex({createdAt: 1}, {expireAfterSeconds: 10});

// Adding a new element triggers mongoDB to 're-do' index on table...
db.sessions.insertOne({data: "dkffyujjslaere", createdAt: new Date()});

// So both items are now gone after 10 seconds
db.sessions.find();



// Covered Query
// When totalDocsExamined = 0

db.customers.insertMany([
    {name: "Max", age: 29, salary: 3000},
    {name: "Manu", age: 30, salary: 4000}
]);

db.customers.createIndex({name: 1});

// So this is a typical plan for a typical plan
db.customers.explain("executionStats").find({name: "Max"});

// Only return indexed fields through projection
// So query is fully covered by index...very fast!
db.customers.explain("executionStats").find({name: "Max"}, {_id: 0, name: 1});




// How MongoDB Rejects a Plan
db.customers.getIndexes();

db.customers.createIndex({age: 1, name: 1});

// Order on filter doesn't matter for index
// You can see the rejected plan was to use just the name
db.customers.explain().find({name: "Max", age: 30});



db.customers.